<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stickmen</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }
        body {
            background: #fff;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);

        class WanderingPoint {
            constructor(x, y, range, biasX = 0, biasY = 0) {
                this.x = x;
                this.y = y;
                this.targetX = x;
                this.targetY = y;
                this.baseX = x;
                this.baseY = y;
                this.range = range;
                this.biasX = biasX;
                this.biasY = biasY;
                this.speed = 0.02 + Math.random() * 0.02;
                this.pickNewTarget();
            }

            pickNewTarget() {
                this.targetX = this.baseX + (Math.random() - 0.5) * this.range * 2;
                this.targetY = this.baseY + (Math.random() - 0.5) * this.range * 2;
                this.timeToNext = 1000 + Math.random() * 3000;
                this.timer = 0;
            }

            update(dt) {
                this.timer += dt;
                if (this.timer > this.timeToNext) {
                    this.pickNewTarget();
                }
                this.x += (this.targetX - this.x) * this.speed;
                this.y += (this.targetY - this.y) * this.speed;

                // Apply tiny bias
                this.baseX += this.biasX * dt;
                this.baseY += this.biasY * dt;
            }
        }

        function drawLimb(ctx, startX, startY, targetX, targetY, len1, len2, flip = 1) {
            const dx = targetX - startX;
            const dy = targetY - startY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const maxLen = len1 + len2;
            const clampedDist = Math.min(dist, maxLen * 0.99);

            const a = len1;
            const b = len2;
            const c = clampedDist;

            let elbowAngle = Math.acos((a * a + b * b - c * c) / (2 * a * b));
            if (isNaN(elbowAngle)) elbowAngle = Math.PI;

            const angleToTarget = Math.atan2(dy, dx);

            let shoulderAngle = Math.acos((a * a + c * c - b * b) / (2 * a * c));
            if (isNaN(shoulderAngle)) shoulderAngle = 0;

            const angle1 = angleToTarget + shoulderAngle * flip;

            const elbowX = startX + Math.cos(angle1) * len1;
            const elbowY = startY + Math.sin(angle1) * len1;

            const angle2 = angle1 - (Math.PI - elbowAngle) * flip;
            const endX = elbowX + Math.cos(angle2) * len2;
            const endY = elbowY + Math.sin(angle2) * len2;

            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(elbowX, elbowY);
            ctx.lineTo(endX, endY);
            ctx.stroke();
        }

        class Stickman {
            constructor(x, y, scale = 1) {
                this.scale = scale;
                this.headRadius = 20 * scale;
                this.bodyLen = 60 * scale;
                this.upperArm = 30 * scale;
                this.lowerArm = 28 * scale;
                this.upperLeg = 35 * scale;
                this.lowerLeg = 33 * scale;

                // Random direction for this stickman
                const angle = Math.random() * Math.PI * 2;
                const speed = 0.002 + Math.random() * 0.002;
                const biasX = Math.cos(angle) * speed;
                const biasY = Math.sin(angle) * speed;

                const shoulderY = y + this.headRadius + 15 * scale;
                const hipY = y + this.headRadius + this.bodyLen;

                // Body anchor point (controls overall drift)
                this.bodyAnchor = new WanderingPoint(x, y, 5 * scale, biasX, biasY);
                // Head wanders independently from body
                this.headOffset = new WanderingPoint(0, 0, 15 * scale, 0, 0);
                // Mouth wanders slightly on the face
                this.mouthOffset = new WanderingPoint(0, 8 * scale, 3 * scale, 0, 0);
                // Mouth curve (positive = smile, negative = frown)
                this.mouthCurve = new WanderingPoint(0, 0, 6 * scale, 0, 0);
                this.leftHand = new WanderingPoint(x - 50 * scale, shoulderY + 20 * scale, 40 * scale, biasX, biasY);
                this.rightHand = new WanderingPoint(x + 50 * scale, shoulderY + 20 * scale, 40 * scale, biasX, biasY);
                this.leftFoot = new WanderingPoint(x - 25 * scale, hipY + 60 * scale, 30 * scale, biasX, biasY);
                this.rightFoot = new WanderingPoint(x + 25 * scale, hipY + 60 * scale, 30 * scale, biasX, biasY);
            }

            update(dt) {
                this.bodyAnchor.update(dt);
                this.headOffset.update(dt);
                this.mouthOffset.update(dt);
                this.mouthCurve.update(dt);
                this.leftHand.update(dt);
                this.rightHand.update(dt);
                this.leftFoot.update(dt);
                this.rightFoot.update(dt);
            }

            draw(ctx) {
                const s = this.scale;
                // Body position is the anchor
                const bodyX = this.bodyAnchor.x;
                const bodyY = this.bodyAnchor.y;
                // Head moves independently relative to body
                const headX = bodyX + this.headOffset.x;
                const headY = bodyY + this.headOffset.y;
                const neckX = bodyX;
                const neckY = bodyY + this.headRadius;
                const shoulderY = neckY + 15 * s;
                const hipY = neckY + this.bodyLen;

                ctx.strokeStyle = '#222';
                ctx.lineWidth = 3 * s;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                // Body
                ctx.beginPath();
                ctx.moveTo(neckX, neckY);
                ctx.lineTo(neckX, hipY);
                ctx.stroke();

                // Neck connecting head to body
                ctx.beginPath();
                ctx.moveTo(headX, headY + this.headRadius * 0.8);
                ctx.lineTo(neckX, neckY);
                ctx.stroke();

                // Arms
                drawLimb(ctx, neckX, shoulderY, this.leftHand.x, this.leftHand.y, this.upperArm, this.lowerArm, 1);
                drawLimb(ctx, neckX, shoulderY, this.rightHand.x, this.rightHand.y, this.upperArm, this.lowerArm, -1);

                // Legs
                drawLimb(ctx, neckX, hipY, this.leftFoot.x, this.leftFoot.y, this.upperLeg, this.lowerLeg, 1);
                drawLimb(ctx, neckX, hipY, this.rightFoot.x, this.rightFoot.y, this.upperLeg, this.lowerLeg, -1);

                // Head
                ctx.beginPath();
                ctx.arc(headX, headY, this.headRadius, 0, Math.PI * 2);
                ctx.fillStyle = '#fff';
                ctx.fill();
                ctx.stroke();

                // Eyes
                ctx.fillStyle = '#222';
                ctx.beginPath();
                ctx.arc(headX - 6 * s, headY - 2 * s, 3 * s, 0, Math.PI * 2);
                ctx.arc(headX + 6 * s, headY - 2 * s, 3 * s, 0, Math.PI * 2);
                ctx.fill();

                // Mouth (curved)
                const mouthX = headX + this.mouthOffset.x;
                const mouthY = headY + this.mouthOffset.y;
                const curve = this.mouthCurve.y;
                ctx.beginPath();
                ctx.moveTo(mouthX - 5 * s, mouthY);
                ctx.quadraticCurveTo(mouthX, mouthY + curve, mouthX + 5 * s, mouthY);
                ctx.stroke();
            }
        }

        // Create multiple stickmen at different positions
        const stickmen = [];

        function init() {
            stickmen.length = 0;
            const count = 5;
            for (let i = 0; i < count; i++) {
                const x = (canvas.width / (count + 1)) * (i + 1) + (Math.random() - 0.5) * 100;
                const y = canvas.height * 0.3 + Math.random() * canvas.height * 0.4;
                const scale = 0.7 + Math.random() * 0.6;
                stickmen.push(new Stickman(x, y, scale));
            }
        }

        init();
        window.addEventListener('resize', () => {
            resize();
            init();
        });

        let lastTime = 0;

        function draw(time) {
            const dt = time - lastTime;
            lastTime = time;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            for (const stickman of stickmen) {
                stickman.update(dt);
                stickman.draw(ctx);
            }

            requestAnimationFrame(draw);
        }

        requestAnimationFrame(draw);
    </script>
</body>
</html>
