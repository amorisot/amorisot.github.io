<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Digital Rothko Generator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #ffffff;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        #canvas {
            cursor: pointer;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Set canvas size
        const WIDTH = 500;
        const HEIGHT = 700;
        canvas.width = WIDTH;
        canvas.height = HEIGHT;

        // Rothko-inspired color palettes
        const palettes = [
            { bg: '#8B4513', colors: ['#FFD700', '#F5F5DC', '#DA70D6'] }, // Yellow, cream, magenta
            { bg: '#2F2F2F', colors: ['#E8E8E8', '#1a1a4e'] }, // White on gray with deep blue
            { bg: '#B8860B', colors: ['#DAA520', '#FFFACD', '#00008B'] }, // Gold, cream, blue
            { bg: '#CD853F', colors: ['#D2691E', '#F5DEB3', '#191970'] }, // Orange, wheat, navy
            { bg: '#4A4A4A', colors: ['#DC143C', '#FF6347', '#8B0000'] }, // Reds
            { bg: '#2E4A3F', colors: ['#228B22', '#90EE90', '#006400'] }, // Greens
            { bg: '#1C1C2E', colors: ['#4169E1', '#87CEEB', '#000080'] }, // Blues
            { bg: '#3D2B1F', colors: ['#FF4500', '#FFD700', '#8B0000'] }, // Orange, yellow, maroon
            { bg: '#2B2B2B', colors: ['#9932CC', '#DDA0DD', '#4B0082'] }, // Purples
            { bg: '#8B7355', colors: ['#F4A460', '#FFEFD5', '#2F4F4F'] }, // Sandy, cream, dark teal
        ];

        // Current painting state
        let currentPalette;
        let rectangles = [];
        let time = 0;
        let noiseOffset = 0;

        // Jagged noise function - higher frequency for rougher edges
        function noise(x, y, t) {
            return Math.sin(x * 0.01 + t) * Math.cos(y * 0.01 + t * 0.7) *
                   Math.sin((x + y) * 0.005 + t * 0.5);
        }

        // Jagged noise with sharp variations
        function jaggedNoise(x, y, t, scale = 1) {
            const n1 = Math.sin(x * scale * 0.15 + t * 2) * Math.cos(y * scale * 0.12 + t);
            const n2 = Math.sin(x * scale * 0.3 + y * scale * 0.2 + t * 1.5);
            const n3 = Math.sin((x + y) * scale * 0.08 + t * 0.8);
            const n4 = Math.sin(x * scale * 0.5) * Math.sin(y * scale * 0.4 + t * 2.5);
            return (n1 + n2 * 0.7 + n3 * 0.5 + n4 * 0.3) / 2.5;
        }

        // Perlin-like smooth noise
        function smoothNoise(x, y, t, scale = 1) {
            const n1 = noise(x * scale, y * scale, t);
            const n2 = noise(x * scale * 2, y * scale * 2, t * 1.5);
            const n3 = noise(x * scale * 0.5, y * scale * 0.5, t * 0.7);
            return (n1 + n2 * 0.5 + n3 * 0.25) / 1.75;
        }

        // Parse hex color to RGB
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 0, b: 0 };
        }

        // Blend two colors
        function blendColors(color1, color2, factor) {
            const c1 = hexToRgb(color1);
            const c2 = hexToRgb(color2);
            return {
                r: Math.round(c1.r + (c2.r - c1.r) * factor),
                g: Math.round(c1.g + (c2.g - c1.g) * factor),
                b: Math.round(c1.b + (c2.b - c1.b) * factor)
            };
        }

        // Generate new composition
        function generateComposition() {
            currentPalette = palettes[Math.floor(Math.random() * palettes.length)];
            rectangles = [];

            const numRects = currentPalette.colors.length;
            const margin = 30 + Math.random() * 20;
            const gap = 15 + Math.random() * 15;
            const availableHeight = HEIGHT - margin * 2 - gap * (numRects - 1);

            let y = margin;

            for (let i = 0; i < numRects; i++) {
                // Vary heights - middle sections often larger in Rothko
                let heightRatio;
                if (numRects === 2) {
                    heightRatio = i === 0 ? 0.6 + Math.random() * 0.1 : 0.3 + Math.random() * 0.1;
                } else if (numRects === 3) {
                    if (i === 0) heightRatio = 0.35 + Math.random() * 0.1;
                    else if (i === 1) heightRatio = 0.25 + Math.random() * 0.1;
                    else heightRatio = 0.3 + Math.random() * 0.1;
                } else {
                    heightRatio = 1 / numRects + (Math.random() - 0.5) * 0.1;
                }

                const rectHeight = availableHeight * heightRatio;
                const xOffset = margin + (Math.random() - 0.5) * 10;
                const widthVariation = (Math.random() - 0.5) * 20;

                // Vary the style: 0 = smooth, 1 = jagged, 0.5 = mixed
                const edgeStyle = Math.random();
                // Whether to show sine waves (and how prominently)
                const sineWaveIntensity = Math.random();

                rectangles.push({
                    x: xOffset,
                    y: y,
                    width: WIDTH - margin * 2 + widthVariation,
                    height: rectHeight,
                    color: currentPalette.colors[i],
                    phase: Math.random() * Math.PI * 2,
                    pulseSpeed: 0.5 + Math.random() * 0.5,
                    edgeSoftness: 20 + Math.random() * 30,
                    breatheAmount: 2 + Math.random() * 4,
                    edgeStyle: edgeStyle,
                    sineWaveIntensity: sineWaveIntensity
                });

                y += rectHeight + gap;
            }
        }

        // Draw a fuzzy, pulsing rectangle
        function drawFuzzyRect(rect, time) {
            const { x, y, width, height, color, phase, pulseSpeed, edgeSoftness, breatheAmount, edgeStyle } = rect;

            // Breathing animation
            const breathe = Math.sin(time * pulseSpeed + phase) * breatheAmount;
            const ax = x - breathe;
            const ay = y - breathe;
            const awidth = width + breathe * 2;
            const aheight = height + breathe * 2;

            // Create image data for pixel manipulation
            const imageData = ctx.getImageData(0, 0, WIDTH, HEIGHT);
            const data = imageData.data;

            const baseColor = hexToRgb(color);
            const bgColor = hexToRgb(currentPalette.bg);

            // Draw fuzzy rectangle
            for (let py = Math.max(0, Math.floor(ay - edgeSoftness));
                 py < Math.min(HEIGHT, Math.ceil(ay + aheight + edgeSoftness)); py++) {
                for (let px = Math.max(0, Math.floor(ax - edgeSoftness));
                     px < Math.min(WIDTH, Math.ceil(ax + awidth + edgeSoftness)); px++) {

                    // Distance from rectangle edges
                    let dx = 0, dy = 0;
                    if (px < ax) dx = ax - px;
                    else if (px > ax + awidth) dx = px - (ax + awidth);
                    if (py < ay) dy = ay - py;
                    else if (py > ay + aheight) dy = py - (ay + aheight);

                    const dist = Math.sqrt(dx * dx + dy * dy);

                    // Blend between smooth and jagged based on edgeStyle
                    const smoothN = smoothNoise(px, py, time * 0.3 + phase, 0.1) * 15;
                    const jaggedN = jaggedNoise(px, py, time * 0.8 + phase, 1) * 25;
                    const edgeNoise = smoothN * (1 - edgeStyle) + jaggedN * edgeStyle;
                    const adjustedDist = dist + edgeNoise;

                    // Soft falloff
                    let alpha = 1;
                    if (adjustedDist > 0) {
                        alpha = Math.max(0, 1 - adjustedDist / edgeSoftness);
                        alpha = alpha * alpha * (3 - 2 * alpha); // Smoothstep
                    }

                    // Internal texture variation
                    const internalNoise = smoothNoise(px, py, time * 0.2, 0.05) * 0.15 + 0.85;

                    // Color variation within the rectangle
                    const colorShift = smoothNoise(px * 0.5, py * 0.5, time * 0.1 + phase, 0.02);

                    if (alpha > 0.01) {
                        const idx = (py * WIDTH + px) * 4;
                        const existingR = data[idx];
                        const existingG = data[idx + 1];
                        const existingB = data[idx + 2];

                        // Vary the color slightly
                        const r = Math.min(255, Math.max(0, baseColor.r * internalNoise + colorShift * 20));
                        const g = Math.min(255, Math.max(0, baseColor.g * internalNoise + colorShift * 20));
                        const b = Math.min(255, Math.max(0, baseColor.b * internalNoise + colorShift * 20));

                        // Blend with existing
                        data[idx] = Math.round(existingR * (1 - alpha) + r * alpha);
                        data[idx + 1] = Math.round(existingG * (1 - alpha) + g * alpha);
                        data[idx + 2] = Math.round(existingB * (1 - alpha) + b * alpha);
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        // Draw animated sine waves around rectangles
        function drawSineWaves(rect, time) {
            const { x, y, width, height, color, phase, sineWaveIntensity } = rect;

            // Skip if intensity is very low
            if (sineWaveIntensity < 0.15) return;

            const baseColor = hexToRgb(color);
            // Much more subtle - scale opacity by intensity
            const baseOpacity = 0.08 + sineWaveIntensity * 0.12;

            ctx.strokeStyle = `rgba(${baseColor.r}, ${baseColor.g}, ${baseColor.b}, ${baseOpacity})`;
            ctx.lineWidth = 0.5 + sineWaveIntensity * 0.5;

            // Amplitude scales with intensity
            const amp = 2 + sineWaveIntensity * 3;

            // Top edge sine wave
            ctx.beginPath();
            for (let px = x - 10; px < x + width + 10; px += 3) {
                const waveY = y - 3 + Math.sin(px * 0.04 + time * 1.5 + phase) * amp
                            + Math.sin(px * 0.09 + time * 1.1) * (amp * 0.4);
                if (px === x - 10) ctx.moveTo(px, waveY);
                else ctx.lineTo(px, waveY);
            }
            ctx.stroke();

            // Bottom edge sine wave
            ctx.beginPath();
            for (let px = x - 10; px < x + width + 10; px += 3) {
                const waveY = y + height + 3 + Math.sin(px * 0.05 + time * 1.4 + phase + 1) * amp
                            + Math.sin(px * 0.08 + time * 1.7) * (amp * 0.4);
                if (px === x - 10) ctx.moveTo(px, waveY);
                else ctx.lineTo(px, waveY);
            }
            ctx.stroke();

            // Only draw side waves if intensity is higher
            if (sineWaveIntensity > 0.4) {
                // Left edge sine wave
                ctx.beginPath();
                for (let py = y - 10; py < y + height + 10; py += 3) {
                    const waveX = x - 3 + Math.sin(py * 0.05 + time * 1.2 + phase + 2) * amp
                                + Math.sin(py * 0.11 + time * 1.5) * (amp * 0.4);
                    if (py === y - 10) ctx.moveTo(waveX, py);
                    else ctx.lineTo(waveX, py);
                }
                ctx.stroke();

                // Right edge sine wave
                ctx.beginPath();
                for (let py = y - 10; py < y + height + 10; py += 3) {
                    const waveX = x + width + 3 + Math.sin(py * 0.045 + time * 1.6 + phase + 3) * amp
                                + Math.sin(py * 0.1 + time * 1.3) * (amp * 0.4);
                    if (py === y - 10) ctx.moveTo(waveX, py);
                    else ctx.lineTo(waveX, py);
                }
                ctx.stroke();
            }

            // Internal waves only for high intensity
            if (sineWaveIntensity > 0.7) {
                ctx.strokeStyle = `rgba(${Math.min(255, baseColor.r + 30)}, ${Math.min(255, baseColor.g + 30)}, ${Math.min(255, baseColor.b + 30)}, ${baseOpacity * 0.5})`;
                ctx.lineWidth = 0.5;

                const numWaves = Math.floor(1 + sineWaveIntensity * 2);
                for (let i = 0; i < numWaves; i++) {
                    const waveY = y + height * (0.3 + i * 0.25);
                    ctx.beginPath();
                    for (let px = x + 15; px < x + width - 15; px += 4) {
                        const offsetY = waveY + Math.sin(px * 0.06 + time * 1.2 + i * 2 + phase) * 4
                                      + Math.sin(px * 0.12 + time * 1.8 + i + phase) * 2;
                        if (px === x + 15) ctx.moveTo(px, offsetY);
                        else ctx.lineTo(px, offsetY);
                    }
                    ctx.stroke();
                }
            }
        }

        // Add film grain effect
        function addGrain(amount = 15) {
            const imageData = ctx.getImageData(0, 0, WIDTH, HEIGHT);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                const grain = (Math.random() - 0.5) * amount;
                data[i] = Math.min(255, Math.max(0, data[i] + grain));
                data[i + 1] = Math.min(255, Math.max(0, data[i + 1] + grain));
                data[i + 2] = Math.min(255, Math.max(0, data[i + 2] + grain));
            }

            ctx.putImageData(imageData, 0, 0);
        }

        // Main render loop
        function render() {
            time += 0.016; // Roughly 60fps timing

            // Draw background with subtle variation
            const bgColor = hexToRgb(currentPalette.bg);
            ctx.fillStyle = currentPalette.bg;
            ctx.fillRect(0, 0, WIDTH, HEIGHT);

            // Add background texture
            const bgImageData = ctx.getImageData(0, 0, WIDTH, HEIGHT);
            const bgData = bgImageData.data;
            for (let py = 0; py < HEIGHT; py++) {
                for (let px = 0; px < WIDTH; px++) {
                    const idx = (py * WIDTH + px) * 4;
                    const n = smoothNoise(px, py, time * 0.1, 0.02) * 10;
                    bgData[idx] = Math.min(255, Math.max(0, bgData[idx] + n));
                    bgData[idx + 1] = Math.min(255, Math.max(0, bgData[idx + 1] + n));
                    bgData[idx + 2] = Math.min(255, Math.max(0, bgData[idx + 2] + n));
                }
            }
            ctx.putImageData(bgImageData, 0, 0);

            // Draw each rectangle
            for (const rect of rectangles) {
                drawFuzzyRect(rect, time);
            }

            // Draw sine waves on top
            for (const rect of rectangles) {
                drawSineWaves(rect, time);
            }

            // Add subtle grain
            addGrain(8);

            requestAnimationFrame(render);
        }

        // Event listeners
        canvas.addEventListener('click', generateComposition);
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                generateComposition();
            }
        });

        // Start
        generateComposition();
        render();
    </script>
</body>
</html>
