<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Masks</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            min-height: 100vh;
            background: #d4c9b8;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 40px;
        }

        .wall {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 30px;
            max-width: 1000px;
        }

        canvas {
            filter: drop-shadow(4px 6px 8px rgba(0,0,0,0.3));
        }
    </style>
</head>
<body>
    <div class="wall" id="wall"></div>

    <script>
        function rand(min, max) {
            return min + Math.random() * (max - min);
        }

        function randInt(min, max) {
            return Math.floor(rand(min, max + 1));
        }

        function pick(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
        }

        // Generate rough stone-like texture across the entire mask
        function fillTexture(ctx, w, h, baseR, baseG, baseB, isInside) {
            const imageData = ctx.getImageData(0, 0, w, h);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                // Only texture pixels that have been drawn (alpha > 0)
                if (data[i + 3] > 0) {
                    const noise = rand(-18, 18);
                    const grain = Math.random() > 0.97 ? rand(-30, 10) : 0;
                    const r = Math.max(0, Math.min(255, baseR + noise + grain));
                    const g = Math.max(0, Math.min(255, baseG + noise + grain));
                    const b = Math.max(0, Math.min(255, baseB + noise + grain));
                    data[i] = r;
                    data[i + 1] = g;
                    data[i + 2] = b;
                }
            }
            ctx.putImageData(imageData, 0, 0);
        }

        // Draw a bumpy, irregular outline by displacing points along a shape
        function bumpyEllipse(ctx, cx, cy, rx, ry, bumpiness, points) {
            ctx.beginPath();
            for (let i = 0; i <= points; i++) {
                const angle = (i / points) * Math.PI * 2;
                const bump = rand(-bumpiness, bumpiness);
                const x = cx + (rx + bump) * Math.cos(angle);
                const y = cy + (ry + bump) * Math.sin(angle);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
        }

        // Diamond/angular head shape
        function angularHead(ctx, cx, cy, w, h, bumpiness, points) {
            ctx.beginPath();
            // Top point, right, bottom, left with bumps
            const pts = [
                [cx, cy - h * 0.5],  // top
                [cx + w * 0.45, cy - h * 0.1], // upper right
                [cx + w * 0.35, cy + h * 0.25], // lower right
                [cx, cy + h * 0.5],  // bottom
                [cx - w * 0.35, cy + h * 0.25], // lower left
                [cx - w * 0.45, cy - h * 0.1], // upper left
            ];
            for (let i = 0; i <= points; i++) {
                const t = (i / points) * pts.length;
                const idx = Math.floor(t) % pts.length;
                const next = (idx + 1) % pts.length;
                const frac = t - Math.floor(t);
                const x = pts[idx][0] + (pts[next][0] - pts[idx][0]) * frac + rand(-bumpiness, bumpiness);
                const y = pts[idx][1] + (pts[next][1] - pts[idx][1]) * frac + rand(-bumpiness, bumpiness);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
        }

        // Elongated head shape
        function elongatedHead(ctx, cx, cy, w, h, bumpiness, points) {
            ctx.beginPath();
            for (let i = 0; i <= points; i++) {
                const angle = (i / points) * Math.PI * 2;
                // Taller, narrower - squash horizontally at middle
                const squeeze = 1 - 0.3 * Math.pow(Math.sin(angle), 2);
                const rx = w * 0.35 * squeeze;
                const ry = h * 0.5;
                const bump = rand(-bumpiness, bumpiness);
                const x = cx + (rx + bump) * Math.cos(angle);
                const y = cy + (ry + bump) * Math.sin(angle);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
        }

        function drawMask(canvas) {
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;

            // Clear with transparent background
            ctx.clearRect(0, 0, w, h);

            const cx = w * 0.5;
            const cy = h * 0.5;

            // Dark charcoal base color with slight variation
            const base = randInt(35, 55);
            const baseR = base + randInt(-5, 5);
            const baseG = base + randInt(-5, 5);
            const baseB = base + randInt(-3, 8); // slightly bluish sometimes

            const headShape = pick(['round', 'elongated', 'angular', 'round', 'round']);
            const bumpiness = rand(3, 8);

            // Draw head shape
            ctx.fillStyle = `rgb(${baseR},${baseG},${baseB})`;
            if (headShape === 'round') {
                bumpyEllipse(ctx, cx, cy, w * rand(0.35, 0.44), h * rand(0.38, 0.46), bumpiness, 80);
            } else if (headShape === 'elongated') {
                elongatedHead(ctx, cx, cy, w, h, bumpiness, 80);
            } else {
                angularHead(ctx, cx, cy, w, h, bumpiness, 80);
            }
            ctx.fill();

            // Apply stone texture to the head
            fillTexture(ctx, w, h, baseR, baseG, baseB);

            // Add surface relief - rough strokes across the surface
            ctx.save();
            ctx.globalCompositeOperation = 'source-atop';
            for (let i = 0; i < 300; i++) {
                const sx = rand(cx - w * 0.4, cx + w * 0.4);
                const sy = rand(cy - h * 0.45, cy + h * 0.45);
                const len = rand(2, 12);
                const angle = rand(0, Math.PI * 2);
                const dark = rand(-25, 15);
                ctx.strokeStyle = `rgba(${baseR + dark},${baseG + dark},${baseB + dark}, ${rand(0.1, 0.4)})`;
                ctx.lineWidth = rand(0.5, 2);
                ctx.beginPath();
                ctx.moveTo(sx, sy);
                ctx.lineTo(sx + Math.cos(angle) * len, sy + Math.sin(angle) * len);
                ctx.stroke();
            }
            ctx.restore();

            // Eye sockets
            const eyeY = cy + h * rand(-0.12, -0.04);
            const eyeSpacing = w * rand(0.11, 0.18);
            const eyeStyle = pick(['round', 'round', 'hollow', 'deep', 'sleepy']);
            const eyeR = w * rand(0.07, 0.13);

            if (eyeStyle === 'sleepy') {
                // Almond/crescent shaped sculpted indentations (not holes)
                // Like the sad elongated Rondinone face
                ctx.save();
                ctx.globalCompositeOperation = 'source-atop';
                for (let side of [-1, 1]) {
                    const ex = cx + side * eyeSpacing;

                    // Deep recessed eye socket area
                    ctx.fillStyle = `rgba(${baseR - 25},${baseG - 25},${baseB - 25}, 0.7)`;
                    bumpyEllipse(ctx, ex, eyeY, eyeR * 1.4, eyeR * 1.0, 2, 20);
                    ctx.fill();

                    // Almond/crescent eyelid shape - darker carved line
                    ctx.strokeStyle = `rgba(${Math.max(0, baseR - 40)},${Math.max(0, baseG - 40)},${Math.max(0, baseB - 40)}, 0.9)`;
                    ctx.lineWidth = rand(2.5, 5);
                    ctx.beginPath();
                    ctx.moveTo(ex - eyeR * 1.1, eyeY);
                    ctx.quadraticCurveTo(ex, eyeY - eyeR * 0.6, ex + eyeR * 1.1, eyeY);
                    ctx.stroke();

                    // Lower lid - subtle
                    ctx.lineWidth = rand(1.5, 3);
                    ctx.beginPath();
                    ctx.moveTo(ex - eyeR * 0.9, eyeY + rand(1, 3));
                    ctx.quadraticCurveTo(ex, eyeY + eyeR * 0.3, ex + eyeR * 0.9, eyeY + rand(1, 3));
                    ctx.stroke();
                }
                ctx.restore();
            } else {
                // Cut-out eye holes (round, hollow, deep)

                // Draw recessed eye area (darker ring around eyes)
                ctx.save();
                ctx.globalCompositeOperation = 'source-atop';
                for (let side of [-1, 1]) {
                    const ex = cx + side * eyeSpacing;
                    ctx.fillStyle = `rgba(${baseR - 20},${baseG - 20},${baseB - 20}, 0.6)`;
                    ctx.beginPath();
                    ctx.arc(ex, eyeY, eyeR * 1.5, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();

                // Cut out the eye holes
                ctx.save();
                ctx.globalCompositeOperation = 'destination-out';
                for (let side of [-1, 1]) {
                    const ex = cx + side * eyeSpacing;
                    if (eyeStyle === 'round' || eyeStyle === 'hollow') {
                        ctx.beginPath();
                        ctx.arc(ex, eyeY, eyeR, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        // Slightly irregular holes
                        bumpyEllipse(ctx, ex, eyeY, eyeR, eyeR * rand(0.8, 1.2), 2, 20);
                        ctx.fill();
                    }
                }
                ctx.restore();

                // Draw dark interior visible through eye holes
                ctx.save();
                ctx.globalCompositeOperation = 'destination-over';
                ctx.fillStyle = `rgb(${Math.max(0, baseR - 30)},${Math.max(0, baseG - 30)},${Math.max(0, baseB - 30)})`;
                for (let side of [-1, 1]) {
                    const ex = cx + side * eyeSpacing;
                    ctx.beginPath();
                    ctx.arc(ex, eyeY, eyeR * 1.3, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();

                // Optional: pupils/eyeballs visible inside some eye holes
                if (Math.random() > 0.4) {
                    ctx.save();
                    ctx.globalCompositeOperation = 'destination-over';
                    const pupilColor = `rgb(${baseR + 10},${baseG + 10},${baseB + 10})`;
                    ctx.fillStyle = pupilColor;
                    for (let side of [-1, 1]) {
                        const ex = cx + side * eyeSpacing;
                        const pr = eyeR * rand(0.3, 0.55);
                        ctx.beginPath();
                        ctx.arc(ex + rand(-2, 2), eyeY + rand(-2, 2), pr, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.restore();
                }
            }

            // Nose
            const noseY = cy + h * rand(0.02, 0.1);
            const noseStyle = pick(['ridge', 'bump', 'none', 'none']);

            ctx.save();
            ctx.globalCompositeOperation = 'source-atop';
            if (noseStyle === 'ridge') {
                // Vertical ridge
                ctx.strokeStyle = `rgba(${baseR - 15},${baseG - 15},${baseB - 15}, 0.7)`;
                ctx.lineWidth = rand(2, 5);
                ctx.beginPath();
                ctx.moveTo(cx, eyeY + eyeR * 0.5);
                ctx.lineTo(cx, noseY + h * 0.06);
                ctx.stroke();
            } else if (noseStyle === 'bump') {
                // Small protruding bump shadow
                ctx.fillStyle = `rgba(${baseR - 12},${baseG - 12},${baseB - 12}, 0.5)`;
                bumpyEllipse(ctx, cx, noseY, w * 0.04, h * 0.03, 1, 12);
                ctx.fill();
            }
            ctx.restore();

            // Mouth
            const mouthY = cy + h * rand(0.15, 0.28);
            const mouthW = w * rand(0.2, 0.4);
            const mouthH = h * rand(0.03, 0.08);
            const mouthStyle = pick(['grin', 'grin', 'toothy', 'toothy', 'toothy', 'frown', 'open', 'teeth']);

            if (mouthStyle === 'toothy') {
                // Big prominent interlocking teeth - like the carved masks
                const bigMouthW = w * rand(0.35, 0.5);
                const bigMouthH = h * rand(0.06, 0.12);

                // Cut wide mouth opening
                ctx.save();
                ctx.globalCompositeOperation = 'destination-out';
                ctx.beginPath();
                ctx.moveTo(cx - bigMouthW / 2, mouthY - bigMouthH / 2);
                ctx.quadraticCurveTo(cx, mouthY - bigMouthH * 0.8, cx + bigMouthW / 2, mouthY - bigMouthH / 2);
                ctx.quadraticCurveTo(cx, mouthY + bigMouthH * 1.8, cx - bigMouthW / 2, mouthY - bigMouthH / 2);
                ctx.fill();
                ctx.restore();

                // Interlocking teeth - draw BEFORE dark interior so they appear in front
                const numTeeth = randInt(8, 16);
                const teethStyle = pick(['pointed', 'blocky', 'jagged']);
                ctx.save();
                ctx.globalCompositeOperation = 'destination-over';
                ctx.fillStyle = `rgb(${baseR + 5},${baseG + 5},${baseB + 5})`;
                for (let i = 0; i < numTeeth; i++) {
                    const t = (i + 0.5) / numTeeth;
                    const tx = cx - bigMouthW / 2 + bigMouthW * t;
                    const toothW = bigMouthW / numTeeth * rand(0.55, 0.85);
                    const fromTop = i % 2 === 0;

                    if (fromTop) {
                        // Teeth hanging down from top
                        const toothH = rand(bigMouthH * 1.2, bigMouthH * 2.5);
                        ctx.beginPath();
                        if (teethStyle === 'blocky') {
                            ctx.rect(tx - toothW / 2, mouthY - bigMouthH / 2, toothW, toothH);
                        } else {
                            ctx.moveTo(tx - toothW / 2, mouthY - bigMouthH / 2);
                            ctx.lineTo(tx + toothW / 2, mouthY - bigMouthH / 2);
                            ctx.lineTo(tx + rand(-1, 1), mouthY - bigMouthH / 2 + toothH);
                        }
                        ctx.closePath();
                        ctx.fill();
                    } else {
                        // Teeth growing up from bottom
                        const toothH = rand(bigMouthH * 1.0, bigMouthH * 2.0);
                        const bottomY = mouthY + bigMouthH * 0.8;
                        ctx.beginPath();
                        if (teethStyle === 'blocky') {
                            ctx.rect(tx - toothW / 2, bottomY - toothH, toothW, toothH);
                        } else {
                            ctx.moveTo(tx - toothW / 2, bottomY);
                            ctx.lineTo(tx + toothW / 2, bottomY);
                            ctx.lineTo(tx + rand(-1, 1), bottomY - toothH);
                        }
                        ctx.closePath();
                        ctx.fill();
                    }
                }
                ctx.restore();

                // Dark interior - drawn after teeth so it goes behind them
                ctx.save();
                ctx.globalCompositeOperation = 'destination-over';
                ctx.fillStyle = `rgb(${Math.max(0, baseR - 40)},${Math.max(0, baseG - 40)},${Math.max(0, baseB - 40)})`;
                ctx.beginPath();
                ctx.moveTo(cx - bigMouthW / 2, mouthY - bigMouthH / 2);
                ctx.quadraticCurveTo(cx, mouthY - bigMouthH * 0.8, cx + bigMouthW / 2, mouthY - bigMouthH / 2);
                ctx.quadraticCurveTo(cx, mouthY + bigMouthH * 2.2, cx - bigMouthW / 2, mouthY - bigMouthH / 2);
                ctx.fill();
                ctx.restore();
            } else if (mouthStyle === 'grin' || mouthStyle === 'teeth') {
                // Wide grinning mouth with teeth
                // Cut mouth hole
                ctx.save();
                ctx.globalCompositeOperation = 'destination-out';
                ctx.beginPath();
                // Slightly curved grin
                ctx.moveTo(cx - mouthW / 2, mouthY);
                ctx.quadraticCurveTo(cx, mouthY + mouthH * 2, cx + mouthW / 2, mouthY);
                ctx.quadraticCurveTo(cx, mouthY + mouthH * 3.5, cx - mouthW / 2, mouthY);
                ctx.fill();
                ctx.restore();

                // Dark interior
                ctx.save();
                ctx.globalCompositeOperation = 'destination-over';
                ctx.fillStyle = `rgb(${Math.max(0, baseR - 35)},${Math.max(0, baseG - 35)},${Math.max(0, baseB - 35)})`;
                ctx.beginPath();
                ctx.moveTo(cx - mouthW / 2, mouthY);
                ctx.quadraticCurveTo(cx, mouthY + mouthH * 2, cx + mouthW / 2, mouthY);
                ctx.quadraticCurveTo(cx, mouthY + mouthH * 4, cx - mouthW / 2, mouthY);
                ctx.fill();
                ctx.restore();

                // Teeth - pointed, irregular
                const numTeeth = randInt(6, 14);
                ctx.save();
                ctx.globalCompositeOperation = 'destination-over';
                ctx.fillStyle = `rgb(${baseR + 5},${baseG + 5},${baseB + 5})`;
                for (let i = 0; i < numTeeth; i++) {
                    const t = i / (numTeeth - 1);
                    const tx = cx - mouthW / 2 + mouthW * t;
                    // Teeth hang down from top of mouth
                    const toothH = rand(mouthH * 0.8, mouthH * 2.2);
                    const toothW = mouthW / numTeeth * rand(0.4, 0.8);
                    ctx.beginPath();
                    ctx.moveTo(tx - toothW / 2, mouthY + 1);
                    ctx.lineTo(tx + toothW / 2, mouthY + 1);
                    ctx.lineTo(tx + rand(-1, 1), mouthY + toothH);
                    ctx.closePath();
                    ctx.fill();
                }
                ctx.restore();
            } else if (mouthStyle === 'frown') {
                // Sad downturned mouth - carved line
                ctx.save();
                ctx.globalCompositeOperation = 'source-atop';
                ctx.strokeStyle = `rgba(${baseR - 25},${baseG - 25},${baseB - 25}, 0.9)`;
                ctx.lineWidth = rand(3, 6);
                ctx.beginPath();
                ctx.moveTo(cx - mouthW / 2, mouthY + mouthH);
                ctx.quadraticCurveTo(cx, mouthY - mouthH * 3, cx + mouthW / 2, mouthY + mouthH);
                ctx.stroke();
                ctx.restore();
            } else if (mouthStyle === 'open') {
                // Round open mouth (surprised/screaming)
                const mouthR = Math.min(mouthW, h * 0.08) * rand(0.4, 0.7);
                ctx.save();
                ctx.globalCompositeOperation = 'destination-out';
                ctx.beginPath();
                ctx.arc(cx, mouthY, mouthR, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();

                // Dark interior
                ctx.save();
                ctx.globalCompositeOperation = 'destination-over';
                ctx.fillStyle = `rgb(${Math.max(0, baseR - 35)},${Math.max(0, baseG - 35)},${Math.max(0, baseB - 35)})`;
                ctx.beginPath();
                ctx.arc(cx, mouthY, mouthR * 1.2, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            // Add more surface texture on top - chisel marks
            ctx.save();
            ctx.globalCompositeOperation = 'source-atop';
            for (let i = 0; i < 150; i++) {
                const sx = rand(cx - w * 0.4, cx + w * 0.4);
                const sy = rand(cy - h * 0.45, cy + h * 0.45);
                const dark = rand(-8, 8);
                ctx.fillStyle = `rgba(${baseR + dark},${baseG + dark},${baseB + dark}, ${rand(0.05, 0.2)})`;
                ctx.beginPath();
                ctx.arc(sx, sy, rand(1, 4), 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();

            // Edge darkening - vignette on the mask edges
            ctx.save();
            ctx.globalCompositeOperation = 'source-atop';
            const gradient = ctx.createRadialGradient(cx, cy, w * 0.15, cx, cy, w * 0.5);
            gradient.addColorStop(0, 'rgba(0,0,0,0)');
            gradient.addColorStop(1, 'rgba(0,0,0,0.25)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, w, h);
            ctx.restore();
        }

        function generateWall() {
            const wall = document.getElementById('wall');
            wall.innerHTML = '';

            const count = randInt(5, 7);
            for (let i = 0; i < count; i++) {
                const canvas = document.createElement('canvas');
                const size = randInt(180, 280);
                canvas.width = size;
                canvas.height = size * rand(1.1, 1.5);
                drawMask(canvas);
                // Slight random rotation like hung on a wall
                canvas.style.transform = `rotate(${rand(-8, 8)}deg)`;
                wall.appendChild(canvas);
            }
        }

        generateWall();

        // Click to regenerate
        document.body.addEventListener('click', generateWall);
    </script>
</body>
</html>
